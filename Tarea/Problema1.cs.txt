public class Node
{
    public int Value { get; set; } // Valor del nodo
    public Node Next { get; set; } // Referencia al siguiente nodo en la lista
    public Node Previous { get; set; } // Referencia al nodo anterior en la lista

    // Constructor que inicializa el nodo con un valor
    public Node(int value)
    {
        Value = value;
    }
}

public enum SortDirection
{
    Asc,
    Desc
}

public interface IList
{
    void InsertInOrder(int value);
    int DeleteFirst();
    int DeleteLast();
    bool DeleteValue(int value);
    int GetMiddle();
    void MergeSortedLists(IList listA, IList listB, SortDirection direction);
}

public class Problema1 : IList
{
    public Node Head { get; private set; }
    public Node Tail { get; private set; }
    private int Count { get; set; }

    public void InsertInOrder(int value)
    {
        var newNode = new Node(value);
        if (Head == null)
        {
            // La lista está vacía
            Head = Tail = newNode;
        }
        else
        {
            var current = Head;
            while (current != null && current.Value < value)
            {
                current = current.Next;
            }

            if (current == null)
            {
                // Insertar al final
                Tail.Next = newNode;
                newNode.Previous = Tail;
                Tail = newNode;
            }
            else if (current == Head)
            {
                // Insertar al principio
                newNode.Next = Head;
                Head.Previous = newNode;
                Head = newNode;
            }
            else
            {
                // Insertar en el medio
                newNode.Previous = current.Previous;
                newNode.Next = current;
                current.Previous.Next = newNode;
                current.Previous = newNode;
            }
        }

        Count++;
    }

    public int DeleteFirst()
    {
        if (Head == null)
        {
            throw new InvalidOperationException("List is empty.");
        }

        int value = Head.Value;

        Head = Head.Next;

        if (Head != null)
        {
            Head.Previous = null;
        }
        else
        {
            Tail = null;
        }

        Count--;
        return value;
    }

    public int DeleteLast()
    {
        if (Tail == null)
        {
            throw new InvalidOperationException("List is empty.");
        }

        int value = Tail.Value;

        Tail = Tail.Previous;

        if (Tail != null)
        {
            Tail.Next = null;
        }
        else
        {
            Head = null;
        }

        Count--;
        return value;
    }

    public bool DeleteValue(int value)
    {
        if (Head == null)
        {
            return false; // Lista vacía
        }

        var current = Head;

        // Buscar el nodo con el valor especificado
        while (current != null)
        {
            if (current.Value == value)
            {
                // Si el nodo a eliminar es el único nodo
                if (current.Previous == null && current.Next == null)
                {
                    Head = Tail = null;
                }
                // Si el nodo a eliminar es el Head
                else if (current.Previous == null)
                {
                    Head = current.Next;
                    Head.Previous = null;
                }
                // Si el nodo a eliminar es el Tail
                else if (current.Next == null)
                {
                    Tail = current.Previous;
                    Tail.Next = null;
                }
                // Si el nodo a eliminar está en el medio
                else
                {
                    current.Previous.Next = current.Next;
                    current.Next.Previous = current.Previous;
                }

                Count--;
                return true; // Nodo eliminado con éxito
            }
            current = current.Next;
        }

        return false; // Nodo no encontrado
    }

    public int GetMiddle()
    {
        if (Head == null)
        {
            throw new InvalidOperationException("List is empty.");
        }

        var midIndex = Count / 2;
        var current = Head;
        for (int i = 0; i < midIndex; i++)
        {
            current = current.Next;
        }
        return current.Value;
    }

    public void MergeSortedLists(IList listA, IList listB, SortDirection direction)
    {
        if (listA == null || listB == null)
        {
            throw new ArgumentNullException("ListA or ListB cannot be null");
        }

        // Crear una lista temporal para almacenar la combinación de listA y listB
        var mergedList = new Problema1();

        // Variables para iterar sobre listA y listB
        var currentA = listA.Head;
        var currentB = listB.Head;

        // Lógica para mezclar las dos listas en orden Asc o Desc
        while (currentA != null && currentB != null)
        {
            if (direction == SortDirection.Asc)
            {
                if (currentA.Value <= currentB.Value)
                {
                    mergedList.InsertInOrder(currentA.Value);
                    currentA = currentA.Next;
                }
                else
                {
                    mergedList.InsertInOrder(currentB.Value);
                    currentB = currentB.Next;
                }
            }
            else // SortDirection.Desc
            {
                if (currentA.Value >= currentB.Value)
                {
                    mergedList.InsertInOrder(currentA.Value);
                    currentA = currentA.Next;
                }
                else
                {
                    mergedList.InsertInOrder(currentB.Value);
                    currentB = currentB.Next;
                }
            }
        }

        // Añadir los elementos restantes de listA
        while (currentA != null)
        {
            mergedList.InsertInOrder(currentA.Value);
            currentA = currentA.Next;
        }

        // Añadir los elementos restantes de listB
        while (currentB != null)
        {
            mergedList.InsertInOrder(currentB.Value);
            currentB = currentB.Next;
        }

        // Actualizar listA con la lista combinada
        this.Head = mergedList.Head;
        this.Tail = mergedList.Tail;
        this.Count = mergedList.Count;
    }
}
